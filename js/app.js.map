{"version":3,"sources":["app.js","log.js","utils.js","view.js","canvaselement.js","distancecircles.js","particlestars.js","planetsystem.js","search.js","shader.js","spaceobject.js","tabs.js","threescene.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"app.js","sourcesContent":["import Log from './app/log';\r\nimport ThreeScene from './components/threescene.js';\r\n\r\n\r\nexport default class App {\r\n  \r\n  constructor () {\r\n\r\n    this.THREESCENE = new ThreeScene();\r\n    this.setDevelopmentMode();\r\n\r\n  }\r\n\r\n\r\n  setDevelopmentMode () {\r\n\r\n    window.isDevelopmentMode = true;\r\n\r\n  }\r\n\r\n};\r\n\r\nnew App();","export var __useDefault = true;\r\n\r\nexport default class Log {\r\n\r\n  init () {}\r\n\r\n  info (message) {\r\n  \tthis.print(message, 'info');\r\n  }\r\n\r\n  error (message) {\r\n\t\tthis.print(message, 'error');\r\n  }\r\n\r\n  print (message, type = 'info') {\r\n  \tif (typeof(console) === 'object' && window.console.log) {\r\n  \t\tconsole.log(message);\r\n  \t}\r\n  }\r\n}","import THREE from 'three.js';\r\n\r\nexport var __useDefault = true;\r\n\r\n\r\n/**\r\n * Utility class to be used for global functions\r\n */\r\n\r\nexport default class Utils {\r\n\r\n\tconstructor() {\r\n\r\n\t\t// the distance of one astronomical unit in kilometers\r\n\t\tthis.AU = 149597870.700;\r\n\r\n\t\t// the distance for one light year in km\r\n\t\tthis.LY = 10;\r\n\r\n\t\t// the distance of one parsec in light years\r\n\t\tthis.PC = 3.26156;\r\n\r\n\t\t// define how large 1px is in comparison to the the real world size\r\n\t\t// every distance will be divided by this value\r\n\r\n\t\t// 10 px = 100000 ly\r\n\t\tthis.distancePixelRatio = Math.round(this.LY / 10);\r\n\r\n\r\n\t\t// set the default rotation time in days for stars\r\n\t\tthis.defaultStarRotationPeriod = 25.00;\r\n\r\n\t\tthis.radiusSun = 696342; // km\r\n\r\n\r\n\t\tthis.radiusEarth = 6371;\r\n\r\n\t\t// For stars\r\n\t\tthis.radiusStarPixelRatio = 100000000;\r\n\r\n\t\t// For planets, moons, etc\r\n\t\tthis.radiusPixelRatio = 50000;\r\n\r\n\r\n\t\tthis.planetDefaultColor = [0, 0, 200];\r\n\r\n\r\n\t\tthis.orbitTransparency = 0.5;\r\n\r\n\t\tthis.orbitColors = [\r\n\t\t\t0xD59C6F,\r\n\t\t\t0x88bf8b,\r\n\t\t\t0x4682b4,\r\n\t\t\t0xd2691e,\r\n\t\t\t0xf0e68c,\r\n\t\t\t0xffa500,\r\n\t\t\t0xE89296,\r\n\t\t\t0x92DEE8,\r\n\t\t\t0x55732D,\r\n\t\t\t0x0FF7E8,\r\n\r\n\t\t\t0xE3B1E0,\r\n\t\t\t0xCA8E40,\r\n\t\t\t0x983315,\r\n\t\t\t0xA06E00,\r\n\t\t\t0xFFB100,\r\n\t\t\t0xFF6202,\r\n\t\t\t0x00579E,\r\n\t\t\t0x9E600A,\r\n\t\t\t0xFFA301,\r\n\t\t\t0x913E20\r\n\t\t];\r\n\r\n\r\n\r\n\t\tthis.spectralColors = {\r\n\t\t\t'o': 0x9BB0FF, // blue\r\n\t\t\t'b': 0xBBCCFF, // blue white\r\n\t\t\t'a': 0xFBF8FF, // white\r\n\t\t\t'f': 0xFFFFF0, // yellow white\r\n\t\t\t'g': 0xFFFF00, // yellow\r\n\t\t\t'k': 0xFF9833, // orange\r\n\t\t\t'm': 0xBB2020, // red\r\n\t\t\t'l': 0xA52A2A, // red brown\r\n\t\t\t't': 0x964B00, // brown\r\n\t\t\t'y': 0x663300  // dark brown\r\n\t\t};\r\n\r\n\r\n\t}\r\n\r\n\tgetDistance( distance, distanceType = 'ly' ) {\r\n\r\n\t\tif (distanceType.toLowerCase() == 'ly') {\r\n\t\t\treturn (distance * this.LY / this.distancePixelRatio);\r\n\t\t}\t\r\n\r\n\t\tif (distanceType.toLowerCase() == 'au') {\r\n\t\t\treturn (distance * this.AU / this.distancePixelRatio);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tPCToLY (d) {\r\n\r\n\t\treturn (d * this.PC / this.distancePixelRatio);\r\n\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * project from 3d to 2d space\r\n\t */ \r\n\ttoScreenPosition(obj, camera) {\r\n\r\n    var vector = new THREE.Vector3();\r\n\r\n    var widthHalf = 0.5 * window.innerWidth;\r\n    var heightHalf = 0.5 * window.innerHeight;\r\n\r\n    obj.updateMatrixWorld();\r\n    vector.setFromMatrixPosition(obj.matrixWorld);\r\n    vector.project(camera);\r\n\r\n    vector.x = ( vector.x * widthHalf ) + widthHalf;\r\n    vector.y = - ( vector.y * heightHalf ) + heightHalf;\r\n\r\n    return { \r\n      x: vector.x,\r\n      y: vector.y\r\n    };\r\n\r\n\t}\r\n\r\n\r\n\tproject2D (mesh, app) {\r\n\r\n\t\tapp.scene.updateMatrixWorld(true);\r\n\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar pos = position.setFromMatrixPosition( mesh.matrixWorld );\r\n\t\t\r\n\t\tapp.camera.updateMatrixWorld(true);\r\n\r\n\t\t// var vector = app.projector.projectVector(pos.clone(), app.camera);\r\n\t\tvar vector = pos.unproject(app.camera);\r\n\r\n\t\tvar pLocal = new THREE.Vector3(0, 0, -1);\r\n\t\tvar pWorld = pLocal.applyMatrix4( app.camera.matrixWorld );\r\n\t\tvar dir = pWorld.sub( app.camera.position ).normalize();\r\n\r\n\t\tvar scalar = (pos.x - app.camera.position.x) / dir.x;\r\n\t\t// window.utils.debug( scalar );\r\n\t\tif (mesh.name == 'Earth') {\r\n  \t\t// window.utils.debug('Earth pos', scalar);\r\n  \t}\r\n\r\n\t  if (scalar < 0) {\r\n\t  \tconsole.log(mesh.name);\r\n\t  \t// window.utils.debug('object behind camera');\r\n\t  \t// return false; // this means the point was behind the camera, so discard\r\n\t  }\r\n\r\n\t\tvector.x = (vector.x + 1)/2 * window.innerWidth;\r\n\t\tvector.y = -(vector.y - 1)/2 * window.innerHeight;\r\n\r\n\t\treturn vector;\r\n\t}\r\n\r\n\r\n\r\n\t// taken from: http://zachberry.com/blog/tracking-3d-objects-in-2d-with-three-js/\r\n\tgetPosition2D ( object, app ) {\r\n\r\n\t\tapp.scene.updateMatrixWorld(true);\r\n\r\n\t\tvar p, v, percX, percY, left, top;\r\n\r\n\t\t// this will give us position relative to the world\r\n\t\tp = object.position.clone();\r\n\r\n\t\tapp.camera.updateMatrixWorld(true);\r\n\r\n\t\t// unproject will translate position to 2d\r\n\t\tv = p.unproject(app.camera);\r\n\r\n\t\t// Pick a point in front of the camera in camera space:\r\n\t\tvar pLocal = new THREE.Vector3(0, 0, -1);\r\n\r\n\t\t// Now transform that point into world space:\r\n\t\tvar pWorld = pLocal.applyMatrix4( app.camera.matrixWorld );\r\n\t\t\r\n\t\t// You can now construct the desired direction vector:\r\n\t\tvar dir = pWorld.sub( app.camera.position ).normalize();\r\n\r\n\t\tvar scalar = (p.x - app.camera.position.x) / dir.x;\r\n\t\t//window.utils.debug( scalar );\r\n\r\n\t  if (scalar < 0) {\r\n\t  \t// window.utils.debug('object behind camera');\r\n\t  \t// return false; //this means the point was behind the camera, so discard\r\n\t  }\r\n\t\t//window.utils.debug( v );\r\n\r\n\t\t// translate our vector so that percX=0 represents\r\n\t\t// the left edge, percX=1 is the right edge,\r\n\t\t// percY=0 is the top edge, and percY=1 is the bottom edge.\r\n\t\tv.x = (v.x + 1)/2 * window.innerWidth;\r\n\t\tv.y = -(v.y - 1)/2 * window.innerHeight;\r\n\r\n\t\treturn v;\r\n\r\n\t}\r\n\r\n\r\n\ttoRad() {\r\n\r\n\t\treturn Math.PI / 180;\r\n\r\n\t}\r\n\r\n\r\n\t// derived from: https://github.com/mrdoob/three.js/blob/master/examples/js/Detector.js\r\n  isWebGLSupported() {\r\n\r\n    try {\r\n      \r\n      let canvas = document.createElement(\"canvas\");\r\n      return !! window.WebGLRenderingContext && (canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\"));\r\n\r\n    } catch(e) { return false; } \r\n\r\n  }\r\n\r\n  // taken from: http://stackoverflow.com/questions/3177855/how-to-format-numbers-similar-to-stack-overflow-reputation-format\r\n\tnumberFormat(number) {\r\n\t\tvar repString = number.toString();\r\n\r\n\t  if ( number < 1000 ) {\r\n\t\t\trepString = number;\r\n\t  } else if ( number < 1000000 ) {\r\n\t\t\trepString = (Math.round((number / 1000) * 10) / 10) + ' K'\r\n\t  } else if ( number < 1000000000 ) {\r\n\t\t\trepString = (Math.round((number / 1000000) * 10) / 10) + ' Mio'\r\n\t  } else if ( number < 1000000000000000000 ) {\r\n\t\t\trepString = (Math.round((number / 1000000000) * 10) / 10) + ' Bio'\r\n\t  }\r\n\r\n\t  return repString;\r\n\t}\r\n\r\n\r\n\r\n\tgetDimensionToTen( min, max ) {\r\n\r\n\t\tvar size = Math.ceil( max * 100000 ) / 100000;\r\n\r\n\t\tif( max < 0.001 )\r\n\t\t\tsize = Math.ceil( max * 10000 ) / 10000;\r\n\t\telse if( max < 0.01 )\r\n\t\t\tsize = Math.ceil( max * 1000 ) / 1000;\r\n\t\telse if( max < 0.1 )\r\n\t\t\tsize = Math.ceil( max * 100 ) / 100;\r\n\t\telse if( max < 1 )\r\n\t\t\tsize = Math.ceil( max * 10 ) / 10;\r\n\r\n\t\telse {\r\n\t\t\tsize = Math.ceil( max );\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tsize: size,\r\n\t\t\tmax: max,\r\n\t\t\tmin: min,\r\n\t\t\tminPercent: Math.round(min * 100 / size) / 100,\r\n\t\t\tmaxPercent: Math.round(max * 100 / size) / 100\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\tredshiftToParsec (z) {\r\n\r\n\t\t// light speed in km/s\r\n\t\tconst vLight = 299792.458;\r\n\r\n\t\t// hubble constant\r\n\t\tconst h0 = 74.20;\r\n\r\n\r\n\t\tlet parsec = (((((z+1)*(z+1)-1)/((z+1)*(z+1)+1)) * vLight) / h0) * 1000000;\r\n\r\n\t\treturn parsec;\r\n\r\n\t}\r\n\r\n\r\n\r\n\tinFrustum (app, position) {\r\n\r\n\t\tapp.camera.updateMatrix(); \r\n\t\tapp.camera.updateMatrixWorld(); \r\n\r\n\t\tapp.frustum = new THREE.Frustum();\r\n\t\tvar projScreenMatrix = new THREE.Matrix4();\r\n\r\n\t\tprojScreenMatrix.multiplyMatrices( app.camera.projectionMatrix, app.camera.matrixWorldInverse );\r\n\r\n\t\t// app.frustum.setFromMatrix( app.camera.projectionMatrix );\r\n\t\tapp.frustum.setFromMatrix( new THREE.Matrix4().multiplyMatrices( app.camera.projectionMatrix, app.camera.matrixWorldInverse ) );\r\n\r\n\r\n\t\tif (app.frustum.containsPoint( position )){\r\n\t\t  return true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\r\n\r\n  debug(txt) {\r\n\r\n  \tif (window.isDevelopmentMode)\r\n  \t\tconsole.log(txt);\r\n\r\n  }\r\n\r\n\r\n  // taken from: http://jsfiddle.net/Brfp3/3/\r\n\ttextCircle (ctx, text, x, y, radius, space, top){\r\n\t   space = space || 0;\r\n\t   var numRadsPerLetter = (Math.PI - space * 2) / text.length;\r\n\t   ctx.save();\r\n\t   ctx.translate(x,y);\r\n\t   var k = (top) ? 1 : -1; \r\n\t   ctx.rotate(-k * ((Math.PI - numRadsPerLetter) / 2 - space));\r\n\t   for(var i=0;i<text.length;i++){\r\n\t      ctx.save();\r\n\t      ctx.rotate(k*i*(numRadsPerLetter));\r\n\t      ctx.textAlign = \"center\";\r\n\t     \tctx.textBaseline = (!top) ? \"top\" : \"bottom\";\r\n\t     \tctx.fillText(text[i],0,-k*(radius));\r\n\t      ctx.restore();\r\n\t   }\r\n\t   ctx.restore();\r\n\t}\r\n\r\n\r\n}","export var __useDefault = true;\r\n\r\nimport $ from 'jquery';\r\n\r\nimport Utils from './utils';\r\nimport Template from '../views/template';\r\n\r\n\r\n/**\r\n * View base class\r\n * Used for all DOM - related objects\r\n * \r\n */\r\n\r\nexport default class View {\r\n\r\n\tconstructor ( options = {} ) {\r\n\r\n\t\tthis.options = options;\r\n\t\tthis.app = options.app;\r\n\r\n\t\tthis.utils = new Utils();\r\n\t\t\r\n\t\tthis.name = '';\r\n\t\tthis.$view = ``;\r\n\r\n\t}\r\n\r\n\tsetData() {\r\n\r\n\t}\r\n\r\n\trender() {\r\n\r\n\t\tthis.$el = this.$view;\r\n\t\treturn this.$el;\r\n\r\n\t}\r\n\r\n\tgetHtml() {\r\n\r\n\t\treturn this.$el.html();\r\n\r\n\t}\r\n\r\n\tappendTo( $element ) {\r\n\r\n\r\n\r\n\t}\r\n\r\n\r\n\tloadAsynch(url, data, method = 'post', callback = {}, scope = this) {\r\n\r\n\t\tconsole.log('calling', url);\r\n\r\n    if (!data) { data = {}; }\r\n\r\n    if (!method) { method = 'GET'; }\r\n\r\n    $.ajax({\r\n      url: url,\r\n      data: data,\r\n      dataType: 'json',\r\n      type: method,\r\n      success: (response) => {\r\n\r\n        if (response && typeof(callback) == 'function') {\r\n\r\n           callback.call(scope, response);\r\n\r\n        }\r\n\r\n      }\r\n    });\r\n\r\n  }\r\n\r\n}","\r\n//var TooltipView = require('../../views/tooltip_view');\r\n//var InfoboxView = require('../../views/infobox_view');\r\n\r\nimport $ from 'jquery';\r\nimport THREE from 'three.js';\r\n\r\nimport Tooltip from '../views/tooltip';\r\n\r\nexport default class CanvasElement {\r\n\r\n  constructor ( options ) {\r\n\r\n  \tthis.app = options.app;\r\n    this.model = options.object;\r\n    this.pos = options.pos;\r\n    this.type = options.type;\r\n\r\n    this.clicked = false;\r\n\r\n    this.viewHelperGroup = new THREE.Object3D();\r\n\r\n    this.tooltip = new Tooltip();\r\n    this.tooltip.hide();\r\n\r\n    this.render();\r\n\r\n  }\r\n\r\n  render() {\r\n\r\n  \t// render a canvas circle at the screen position\r\n    this.canvas = document.getElementById('canvas');\r\n    this.canvas.width = 24;\r\n    this.canvas.height = 24;\r\n\r\n    var context = this.canvas.getContext('2d');\r\n        context.beginPath();\r\n        context.arc(12, 12, 11, 0, 2 * Math.PI, false);\r\n        context.lineWidth = 2;\r\n        context.strokeStyle = '#99FF66';\r\n        context.stroke();\r\n\r\n\r\n    // add click event (dirty)\r\n    $(document).on('click', '#canvas', (e) => {\r\n\r\n      // dirty: prevent multiple click events\r\n      if (!this.clicked) {\r\n        this.clicked = true;\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n\r\n        /*\r\n        self.infobox = new InfoboxView({\r\n          app: self.app,\r\n          object: self.model,\r\n          data: self.model.properties,\r\n          template: 'star-info'\r\n        });\r\n\r\n        */\r\n      }\r\n\r\n      this.clicked = false;\r\n\r\n    });\r\n\r\n  }\r\n\r\n\r\n  registerObject (object) {\r\n\r\n    this.object = object;\r\n\r\n  }\r\n\r\n\r\n  show () {\r\n\r\n    $('#canvas').css({'opacity': 1.0});\r\n\r\n  }\r\n\r\n  hide () {\r\n\r\n    $('#canvas').css({'opacity': 0.0});\r\n\r\n  }\r\n\r\n\r\n  showTooltip() {\r\n\r\n    this.tooltip.updatePosition(this.pos);\r\n    this.tooltip.setData(this.object);\r\n    this.tooltip.show();\r\n\r\n  }\r\n\r\n  hideTooltip () {\r\n    this.tooltip.hide();\r\n  }\r\n\r\n\r\n  updatePosition (pos) {\r\n\r\n    this.pos = pos;\r\n\r\n    $('#canvas').css({\r\n      'left': pos.x - 12 + 'px',\r\n      'top': pos.y - 12 + 'px',\r\n      'opacity': 1.0\r\n    });\r\n\r\n  }\r\n\r\n\r\n  updateObjectInfo (objectInfo) {\r\n\r\n    this.model = objectInfo;\r\n\r\n  }\r\n\r\n\r\n  showViewHelper() {\r\n\r\n    this.hideViewHelper();\r\n    this.viewHelperGroup = new THREE.Object3D();\r\n\r\n    if (this.app.currentDistanceLY >= 1) {\r\n\r\n      console.log('showing helper lines');\r\n\r\n      var pos = this.model.properties.position;\r\n\r\n      // show two lines\r\n      var material = new THREE.LineBasicMaterial({\r\n        color: 0x0090ff,\r\n        linewidth: 1\r\n      });\r\n\r\n      // define the geometry shape\r\n      var geometry = new THREE.Geometry();\r\n          geometry.vertices.push( new THREE.Vector3(0, 0, 0) );\r\n          geometry.vertices.push( new THREE.Vector3(pos.x, 0, pos.z) );\r\n\r\n      var line1 = new THREE.Line(geometry, material);\r\n\r\n      var geometry = new THREE.Geometry();\r\n          geometry.vertices.push( new THREE.Vector3(pos.x, 0, pos.z) );\r\n          geometry.vertices.push( new THREE.Vector3(pos.x, pos.y, pos.z) );\r\n\r\n      var line2 = new THREE.Line(geometry, material);\r\n\r\n      var geometry = new THREE.Geometry();\r\n          geometry.vertices.push( new THREE.Vector3(0, 0, 0) );\r\n          geometry.vertices.push( new THREE.Vector3(pos.x, pos.y, pos.z) );\r\n\r\n      var line3 = new THREE.Line(geometry, material);\r\n\r\n      this.viewHelperGroup.add(line1);\r\n      this.viewHelperGroup.add(line2);\r\n      this.viewHelperGroup.add(line3);\r\n\r\n      this.app.scene.add(this.viewHelperGroup);\r\n\r\n    }\r\n  }\r\n\r\n\r\n  hideViewHelper() {\r\n\r\n    this.app.scene.remove(this.viewHelperGroup);\r\n\r\n  }\r\n\r\n}\r\n","import THREE from 'three.js';\r\n\r\nimport _ from 'underscore';\r\nimport Utils from '../app/utils';\r\n\r\nexport default class DistanceCircles {\r\n\r\n\tconstructor (options = {}) {\r\n\t\tthis.options = options;\r\n\t\tthis.app = this.options.app;\r\n\r\n\t\tthis.utils = new Utils();\r\n\r\n\t\tthis.distanceObjects = {\r\n\t\t\t'au': [],\r\n\t\t\t'lightyears': []\r\n\t\t};\r\n\r\n\t\tthis.renderRingGroup(5, 'au');\r\n\t\tthis.renderRingGroup(5, 'lightyears');\r\n\t}\r\n \r\n  renderRingGroup (limit, type) {\r\n\r\n  \tvar object = new THREE.Object3D();\r\n\t  var distanceType = this.utils.AU;\r\n\r\n\t  if ( type == 'lightyears' )\r\n\t  \tdistanceType = this.utils.LY;\r\n\t  \r\n\t  // make the steps every 10^x circles\r\n\t\tfor ( var i=0; i<=5; i++ ) {\r\n\r\n\t\t\tif ( i == 5 && type != 'lightyears') \r\n\t\t\t\tbreak;\r\n\r\n\t\t\tvar circleDistance = Math.pow( 10, i ) * (distanceType / this.utils.distancePixelRatio);\r\n\t\t\tvar distanceStep = Math.pow( 10, i );\r\n\r\n\t\t\tvar circle = new THREE.Shape();\r\n\t\t\t\t\tcircle.moveTo( circleDistance, 0 );\r\n\t\t\t\t\tcircle.absarc( 0, 0, circleDistance, 0, Math.PI*2, false );\r\n\t\t\t\r\n\t\t\tvar points = circle.createPointsGeometry(100);\r\n\r\n\t\t\tvar circleLine = new THREE.Line(points, \r\n\t\t\t  new THREE.LineBasicMaterial({ \r\n\t\t      color : 0x00ffff,\r\n\t\t      opacity : 0.5,\r\n\t\t      linewidth: 5,\r\n\t\t      transparent: true,\r\n\t\t      blending: THREE.AdditiveBlending \r\n\t\t\t  })\r\n\t\t\t);\r\n\t\t\t\r\n\t\t\t// add one distanceStep as offset to move it to the center\t\t\r\n\t\t\t//v_circle.position.set(0, -100, 0);\t\t\r\n\t\t\tcircleLine.position.set( 0, 0, 0 );\r\n\t\t\tcircleLine.rotation.set( Math.PI/2, 0, 0 );\r\n\t\t\tcircleLine.visible = false;\r\n\t\t\tcircleLine.properties = {};\r\n\t\t\tcircleLine.properties.distanceScale = distanceStep;\r\n\r\n\t\t\tthis.distanceObjects[ type ].push( circleLine );\r\n\t\t\tobject.add( circleLine );\t\r\n\r\n\t\t\t// for every distance create a canvas text based on a three texture\r\n\t   \tvar canvas = document.createElement('canvas');\r\n\t   \t\t\tcanvas.width = 1024;\r\n\t    \t\tcanvas.height = 1024;\r\n\r\n\t    var context = canvas.getContext('2d'),\r\n\t\t      centerX = canvas.width / 2,\r\n\t\t      centerY = canvas.height / 2,\r\n\t\t      angle = (Math.PI * 0.7),\r\n\t\t      radius = -520;\r\n\r\n\t    //context.clearRect(0, 0, canvas.width, canvas.height);\r\n\t    context.font = '32px Helvetica, Arial';\r\n\t    context.textAlign = 'center';\r\n\t    context.fillStyle = '#00ffff';\r\n\t    context.strokeStyle = '#00ffff';\r\n\t    context.lineWidth = 1;\r\n\r\n\t    var canvasText = distanceStep + ' astronomical unit';\r\n\t \r\n\t\t  if ( type == 'lightyears' )\r\n\t\t  \tcanvasText = distanceStep + ' light year';\r\n\r\n\t\t  if ( i > 0 ) \r\n\t\t  \tcanvasText += 's';\r\n\r\n\t    this.utils.textCircle(context, canvasText, centerX, centerY-480, radius, angle, 1);\r\n\t    context.stroke();\r\n\r\n\t    // taken from: http://stemkoski.github.io/Three.js/Texture-From-Canvas.html\r\n\t\t\t// canvas contents will be used for a texture\r\n\t\t\tvar texture = new THREE.Texture(canvas); \r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\t      \r\n\t  \tvar material = new THREE.MeshBasicMaterial({\r\n\t  \t\tmap: texture, \r\n\t  \t\tcolor: 0x00ffff, \r\n\t  \t\ttransparent: true,\r\n\t  \t\topacity: 1.25,\r\n\t  \t\tside: THREE.DoubleSide,\r\n\t  \t\tblending: THREE.AdditiveBlending \r\n\t  \t});\r\n\r\n\t    material.needsUpdate = true;\r\n\r\n\t    var mesh = new THREE.Mesh(\r\n\t    \tnew THREE.PlaneGeometry(1, 1),\r\n\t   \t\tmaterial\r\n\t   \t);\r\n\r\n\t    mesh.properties = {};\r\n\t    mesh.properties.distanceScale = distanceStep;\r\n\t    mesh.visible = true;\r\n\t\t\tmesh.position.set(0, 0.1, circleDistance);\r\n\t\t\tmesh.rotation.set(-Math.PI/2, 0, 0);\r\n\r\n\t\t\tmesh.scale.x = 2.0 * ( Math.pow( 10, (i+1) ) );\r\n\t\t\tmesh.scale.y = 2.0 * ( Math.pow( 10, (i+1) ) );\r\n\r\n\t\t\tif ( type == 'lightyears' ) {\r\n\t\t\t\tmesh.scale.x = 2.0 * ( Math.pow( 10, (i+1) ) );\r\n\t\t\t\tmesh.scale.y = 2.0 * ( Math.pow( 10, (i+1) ) );\r\n\t\t\t}\r\n\r\n\t\t\tthis.distanceObjects[ type ].push( mesh );\r\n\t\t\tthis.app.scene.add( mesh );\r\n\t\t}\r\n\r\n\t\tthis.app.scene.add( object );\r\n\r\n  }\r\n\r\n\r\n  update (distanceAU, distanceLY) {\r\n\r\n  \t_.each( this.distanceObjects, function( objects, type ){\r\n\r\n\t\t\tif (type == 'au') {\r\n\t\t\t\t_.each( objects, function( object, idx ){\r\n\t\t\t\t\tif( object.properties.distanceScale <= distanceAU )\r\n\t\t\t\t\t\tobject.visible = true;\r\n\r\n\t\t\t\t\telse if( object.properties.distanceScale )\r\n\t\t\t\t\t\tobject.visible = false;\t\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif ( type == 'lightyears') {\r\n\t\t\t\t_.each( objects, function( object, idx ){\r\n\t\t\t\t\tif( object.properties.distanceScale <= distanceLY )\r\n\t\t\t\t\t\tobject.visible = true;\r\n\r\n\t\t\t\t\telse if( object.properties.distanceScale )\r\n\t\t\t\t\t\tobject.visible = false;\t\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t});\r\n\r\n  }\r\n\r\n\r\n  getObject() {\r\n\r\n  \treturn this.objectPlane;\r\n\r\n  }\r\n\r\n}","import THREE from 'three.js';\r\n\r\nimport Utils from '../app/utils';\r\nimport Textures from '../helpers/textures';\r\nimport Particle from '../helpers/particle';\r\n\r\nimport Shader from './shader';\r\n\r\nexport default class ParticleStars {\r\n\r\n\tconstructor ( options = {} ) {\r\n\r\n\t\tthis.options = options;\r\n\t\tthis.app = options.app;\r\n  \tthis.stars = options.stars;\r\n\r\n  \tthis.utils = new Utils();\r\n  \tthis.textures = new Textures();\r\n\r\n\r\n  \tthis.spectralStars = {\r\n      'o': [],\r\n      'b': [],\r\n      'a': [],\r\n      'f': [],\r\n      'g': [],\r\n      'k': [],\r\n      'm': [],\r\n      'l': [],\r\n      't': [],\r\n      'y': []\r\n    };\r\n\r\n    this.particleArray = [];\r\n    this.particleCount = this.stars.length;\r\n\r\n    this.habitableStars = [];\r\n\r\n    this.sizeFlag = '';\r\n\r\n    this.attributes = {\r\n      sizes: [],\r\n      colors: [],\r\n      alpha: []\r\n    };\r\n\r\n    this.uniforms = {\r\n      amplitude: { type: 'f', value: 1.0 },\r\n      texture: { type: 't', value: this.textures.getStarMaterial() }\r\n    };\r\n\r\n    // every spectral class needs its own particle system that are saved \r\n    // to a group\r\n    // multiple textures / colors in one particlesystem is not yet possible with three.js\r\n    this.particleSystems = new THREE.Object3D();\r\n\r\n    this.geometry = new THREE.BufferGeometry();\r\n\r\n    this.setAttributes();\r\n    this.render();\r\n\r\n\t}\r\n\r\n\r\n\tsetAttributes () {\r\n\r\n    let starLength = this.stars.length;\r\n\r\n    let sizes = this.attributes.sizes;\r\n    let colors = this.attributes.colors;\r\n    let alpha = this.attributes.alpha;\r\n\r\n    for ( var i = 0; i < this.stars.length; i++ ) {\r\n\r\n      let spectralType = this.getSpectralType(this.stars[i]);\r\n\r\n      if (this.spectralStars[spectralType])\r\n        this.spectralStars[spectralType].push( this.stars[i] );\r\n\r\n      this.stars[i].spectralType = spectralType;\r\n\r\n      sizes[i] = this.utils.LY * 100 / this.utils.distancePixelRatio;\r\n\r\n      //if (this.utils.spectralColors[ spectralType ] != undefined) {\r\n\r\n        //colors[i] = new THREE.Color( this.utils.spectralColors[ spectralType ] );\r\n\r\n      //} else {\r\n\r\n        //colors[i] = new THREE.Color( 0xffffff );\r\n\r\n      //}\r\n\r\n      alpha[ i ] = 1.0;\r\n\r\n    }\r\n\r\n\r\n\r\n    this.stars.forEach(( star, idx ) => {\r\n\r\n      var $span = $('<span>' + star.pl_hostname + '</span>');\r\n          $span.addClass('star-label');\r\n          $span.addClass('star-label-' + idx);\r\n\r\n      /*\r\n      $this.material = new THREE.ParticleBasicMaterial({\r\n        map: _Textures.getStarMaterial(),\r\n        color: window.settingsspectralColors[ star.type.substr(0, 1).toLowerCase() ],\r\n        transparent: true,\r\n        blending: THREE.AdditiveBlending,\r\n        depthTest: false,\r\n        size: window.settings.stars.size\r\n      });\r\n      */\r\n\r\n      // if distance is unknown we assume a distance of 500 parsec\r\n      if ( !star.dist || star.dist == 0 )\r\n        star.dist = 500;\r\n\r\n      if (star.pl_hostname == 'Sun')\r\n        star.dist = 0;\r\n\r\n      // change distance to light years\r\n      var distance = star.dist * this.utils.PC * this.utils.LY / this.utils.distancePixelRatio;\r\n      var distanceLY = star.dist * this.utils.PC;\r\n\r\n      // make every star the same distance from the center to make them visible\r\n      var normalizedDistance = this.utils.AU / this.utils.distancePixelRatio;\r\n\r\n      // for each particle set the space position depending on its distance, right acsession and declination\r\n      // taken from http://www.stjarnhimlen.se/comp/tutorial.html\r\n      // var x = normalizedDistance * Math.cos( star.ra ) * Math.cos( star.dec );\r\n      // var y = normalizedDistance * Math.sin( star.ra ) * Math.cos( star.dec );\r\n      // var z = normalizedDistance * Math.sin( star.dec );\r\n\r\n      star.ra = star.ra * Math.PI / 180.0;\r\n      star.dec = star.dec * Math.PI / 180.0;\r\n\r\n      // star distance in parsec \r\n      // right acsession in h \r\n      // declination in h \r\n      var x = Math.round( distance * Math.cos( (star.ra*15) ) * Math.cos( star.dec ) );\r\n      var y = Math.round( distance * Math.sin( (star.ra*15) ) * Math.cos( star.dec ) );\r\n      var z = Math.round( distance * Math.sin( star.dec ) );\r\n\r\n      // check star conditions\r\n      if ( this.checkConditions(star) ) {\r\n\r\n        var particle = new Particle({ vector: new THREE.Vector3(x, y, z) });\r\n\r\n        particle.properties = {\r\n          id: star.id,\r\n          name: star.pl_hostname,\r\n          type: star.type,\r\n          distance: star.dist,\r\n          distanceLY: Math.round(star.dist * this.utils.PC),\r\n          mass: star.mass,\r\n          radius: star.radius,\r\n          planets: star.pl_num,\r\n          habitable: star.habitable,\r\n          constellation: star.constellation,\r\n          spectralType: star.spectralType,\r\n          position: new THREE.Vector3(x, y, z)\r\n        }\r\n\r\n        // add it to the geometry\r\n        //this.geometry.position.push( particle.position );\r\n\r\n        //positions[idx + 0] = x / 100000;\r\n        //positions[idx + 1] = y / 100000;\r\n        //positions[idx + 2] = z / 100000;\r\n\r\n        this.particleArray.push( particle );\r\n        this.app.stars.push( particle );\r\n\r\n        if ( parseInt(star.habitable) == 1)\r\n          this.habitableStars.push(particle.properties);\r\n\r\n      } else {\r\n\r\n        console.log( 'star not in range' );\r\n\r\n      }\r\n\r\n    });\r\n\r\n  \r\n    var positions = new Float32Array( starLength * 3 );\r\n    var starColors = new Float32Array( starLength * 3 );\r\n    var starSizes = new Float32Array( starLength );\r\n\r\n    var color = new THREE.Color();\r\n\r\n    for ( var i = 0, i3 = 0; i < this.particleArray.length; i++, i3 += 3 ) {\r\n\r\n      //positions[ i3 + 0 ] = this.particleArray[i].position.x / 100000;\r\n      //positions[ i3 + 1 ] = this.particleArray[i].position.y / 100000;\r\n      //positions[ i3 + 2 ] = this.particleArray[i].position.z / 100000;\r\n\r\n      positions[ i3 + 0 ] = this.particleArray[i].position.x;\r\n      positions[ i3 + 1 ] = this.particleArray[i].position.y;\r\n      positions[ i3 + 2 ] = this.particleArray[i].position.z;\r\n\r\n      starSizes[ i ] = 2000000;\r\n\r\n\r\n      color.setHSL( i / this.particleArray.length, 1.0, 0.5 );\r\n\r\n      starColors[ i3 + 0 ] = color.r;\r\n      starColors[ i3 + 1 ] = color.g;\r\n      starColors[ i3 + 2 ] = color.b;\r\n\r\n      if (this.utils.spectralColors[ this.particleArray[i].properties.spectralType ] != undefined) {\r\n\r\n        color = new THREE.Color( this.utils.spectralColors[ this.particleArray[i].properties.spectralType ] );\r\n\r\n        starColors[ i3 + 0 ] = color.r;\r\n        starColors[ i3 + 1 ] = color.g;\r\n        starColors[ i3 + 2 ] = color.b;\r\n\r\n      }\r\n      \r\n\r\n    }\r\n\r\n\r\n    this.geometry.addAttribute('position', new THREE.BufferAttribute( positions, 3 ) );\r\n    this.geometry.addAttribute('color', new THREE.BufferAttribute( starColors, 3 ) );\r\n    this.geometry.addAttribute('size', new THREE.BufferAttribute( starSizes, 1 ) );\r\n\r\n\t}\r\n\r\n\r\n  checkConditions ( star ) {\r\n\r\n    return true;\r\n\r\n    var distanceLY = star.dist * this.utils.PC;\r\n    //window.utils.debug( distanceLY, star.pl_num );\r\n    if ( star.pl_num >= 6 )\r\n      return true;\r\n  }\r\n\r\n\r\n  getSpectralType (star) {\r\n\r\n    return star.type.substr(0,1).toLowerCase().toString();\r\n\r\n  }\r\n \r\n\r\n  render () {\r\n\r\n  \tvar self = this;\r\n\r\n    this.particleMaterial = new THREE.ShaderMaterial({\r\n\r\n      uniforms: this.uniforms,\r\n      blending: THREE.NormalBlending,\r\n      depthTest: false,\r\n      depthWrite: false,\r\n      transparent: true\r\n\r\n    });\r\n\r\n\r\n    this.shader = new Shader({\r\n\r\n      shader: 'particle-star',\r\n\r\n      uniforms: this.uniforms,\r\n      attributes: this.attributes\r\n\r\n    });\r\n\r\n\r\n    this.loadShader();\r\n\r\n\r\n    this.particleSystem = new THREE.Points(\r\n      this.geometry,\r\n      this.particleMaterial\r\n    );\r\n\r\n    this.particleSystem.dynamic = true;\r\n\r\n    // rotate the whole particle system by 39 degrees\r\n    // see http://www.astronews.com/forum/archive/index.php/t-3533.html\r\n    // particleSystem.rotation.x = -39 * (Math.PI/180);\r\n      \r\n    this.app.scene.add( this.particleSystem );\r\n\t\t\r\n  }\r\n\r\n\r\n  getParticleSystem () {\r\n    return this.particleSystem;\r\n  }\r\n\r\n\r\n  loadShader() {\r\n\r\n    this.shader.load( () => {\r\n\r\n      this.particleMaterial = this.shader.getMaterial();\r\n\r\n    });\r\n\r\n  }\r\n\r\n\r\n\r\n  animate () {\r\n\r\n    var time = Date.now() * 0.0005;\r\n\r\n    // this.particleSystem.rotation.z = 0.01 * time;\r\n\r\n    var sizes = this.geometry.attributes.size.array;\r\n    //var colors = this.geometry.attributes.color.array;\r\n\r\n    //for ( var i = 0; i < this.particleArray.length; i++ ) {\r\n\r\n      //sizes[ i ] = 100 * ( 1 + Math.sin( 0.1 * i + time ) );\r\n\r\n    //}\r\n\r\n    //this.geometry.attributes.size.needsUpdate = true;\r\n    //this.geometry.attributes.color.needsUpdate = true;\r\n\r\n  }\r\n\r\n\r\n}","import THREE from 'three.js';\r\n\r\nimport Utils from '../app/utils';\r\nimport Geometries from '../helpers/geometry';\r\n\r\nimport Star from './spaceobjects/star';\r\nimport Planet from './spaceobjects/planet';\r\nimport Moon from './spaceobjects/moon';\r\n\r\nexport default class PlanetSystem {\r\n  \r\n  constructor (options = {}) {\r\n\r\n    this.options = options;\r\n\r\n    this.app = this.options.app;\r\n    this.stars = this.options.system.stars;\r\n    this.system = this.options.system;\r\n    this.name = this.options.system.name;\r\n    \r\n    this.bodies = [];\r\n\r\n    this.utils = new Utils();\r\n    this.geometries = new Geometries();\r\n\r\n    this.group = new THREE.Group();\r\n\r\n    // this.options.app.scene.add(this.group);\r\n    // this.group.position = new THREE.Vector3(0,0,0); //this.app.center;\r\n\r\n    // this.renderTemparatureZones();\r\n    this.render();\r\n\r\n  }\r\n\r\n  render() {\r\n\r\n    console.log('rendering stars ', this.stars);\r\n\r\n    this.stars[0].parentGroup = this.group;\r\n    this.stars[0].meshes = this.meshes;\r\n    this.stars[0].satellites = this.satellites;\r\n    this.stars[0].orbits = this.orbits;\r\n    this.stars[0].systemName = this.name;\r\n\r\n    this.stars[0].orbitColor = this.orbitColor;\r\n\r\n    this.starObject = new Star({ \r\n      group: this.group,\r\n      app: this.app, \r\n      data: this.stars[0]\r\n    });\r\n\r\n\r\n    for ( var satellite in this.system.satellites ) {\r\n\r\n      var object = this.system.satellites[satellite];\r\n\r\n      // if ( object.type === 'planet' || object.type === 'dwarf-planet' || object.type === 'moon' || object.type === 'comet' ) {\r\n      if (object.type === 'planet' || object.type === 'moon') {\r\n\r\n        var planet = new Planet({ \r\n          app: this.app, \r\n          planetsystem: this,\r\n          data: object, \r\n          group: this.group \r\n        });\r\n\r\n        this.bodies.push(planet);\r\n\r\n        this.group.add(planet.getObject());\r\n\r\n        /*\r\n        for ( moon in object.satellites ) {\r\n\r\n          var obj = object.satellites[moon];\r\n\r\n          new Moon({ \r\n            app: self.app, \r\n            planetsystem: self,\r\n            data: obj, \r\n            group: planetView.objectPlane,\r\n            visible: 0\r\n          });\r\n\r\n        }\r\n        */\r\n\r\n      }\r\n    }\r\n\r\n    this.bodies.push(this.starObject);\r\n\r\n    this.group.add(this.starObject.getObject());\r\n\r\n\r\n  }\r\n\r\n  getObject() {\r\n\r\n    return this.group;\r\n\r\n  }\r\n\r\n\r\n  renderTemparatureZones() {\r\n\r\n    var minHZ = this.stars[0].minhz;\r\n    var maxHZ = this.stars[0].maxhz;\r\n\r\n    var HZPercentDimension = this.utils.getDimensionToTen( minHZ, maxHZ );\r\n\r\n    if ( minHZ && maxHZ ) {\r\n\r\n      console.log('render hab zone: ', minHZ, maxHZ);\r\n\r\n      var normalizedMinHZ = this.utils.getDistance(minHZ, 'au');\r\n      var normalizedMaxHZ = this.utils.getDistance(maxHZ, 'au');\r\n\r\n      var centerHZ = normalizedMaxHZ - normalizedMinHZ;\r\n\r\n      // create 2d zone temparature texture\r\n      var canvas = document.createElement('canvas');\r\n          canvas.width = 256;\r\n          canvas.height = 256;\r\n\r\n      var context = canvas.getContext('2d');\r\n      var centerX = canvas.width / 2;\r\n      var centerY = canvas.height / 2;\r\n      \r\n      var objGradient = context.createRadialGradient( centerX, centerY, 1, centerX, centerY, canvas.width/2 );\r\n\r\n\r\n      var colorStopMin = HZPercentDimension.minPercent - 0.1;\r\n      var colorStopMax = HZPercentDimension.maxPercent + 0.1;\r\n\r\n      if ( colorStopMin <= 0.0) colorStopMin = 0.1;\r\n      if ( colorStopMax >= 1.0) colorStopMax = 0.95;\r\n\r\n      objGradient.addColorStop( 0, 'rgba(255, 25, 25, 1.0)');\r\n      objGradient.addColorStop( colorStopMin, 'rgba(255, 125, 25, 0.5)');\r\n      objGradient.addColorStop( HZPercentDimension.minPercent + 0.1, 'rgba(50, 255, 50, 0.5)');\r\n      objGradient.addColorStop( HZPercentDimension.maxPercent - 0.1, 'rgba(50, 255, 50, 0.5)');\r\n      objGradient.addColorStop( colorStopMax, 'rgba(0, 0, 200, 0.5)');\r\n      objGradient.addColorStop( 1.0, 'rgba(0, 0, 200, 0.01)');\r\n\r\n      context.fillStyle = objGradient;\r\n\r\n      context.beginPath();\r\n      context.arc( centerX, centerY, canvas.width/2, 0, 2*Math.PI, false );\r\n      context.fill();\r\n      \r\n      var texture = new THREE.Texture(canvas); \r\n          texture.needsUpdate = true;\r\n          \r\n      var material = new THREE.MeshBasicMaterial({\r\n        map: texture,\r\n        transparent: true,\r\n        opacity: 0.4,\r\n        side: THREE.DoubleSide,\r\n        blending: THREE.NormalBlending\r\n      });\r\n\r\n      //var dimension = (centerHZ*2) + ( (centerHZ*2) * 75 / 100 )*2;\r\n      var dimension = this.utils.getDistance(2 * HZPercentDimension.size, 'au');\r\n\r\n      console.log(dimension);\r\n\r\n      var mesh = new THREE.Mesh(\r\n        new THREE.PlaneGeometry( dimension, dimension ),\r\n        material\r\n      );\r\n\r\n      mesh.material.needsUpdate = true;\r\n\r\n      //mesh.position.set( 0, - window.exoplanetsystems.systems.length * 10, 0 );\r\n      mesh.position.set( 0, this.app.systems.length * 5, 0 );\r\n      mesh.rotation.set( -90 * Math.PI / 180, 0, 0 );\r\n\r\n      // render the specific limits as well   \r\n      var innerHZLine = this.geometries.renderDashedCircle( normalizedMinHZ, new THREE.Color('rgba(255, 50, 255, 0.75)') );\r\n      var outerHZLine = this.geometries.renderDashedCircle( normalizedMaxHZ, new THREE.Color('rgba(255, 50, 255, 0.75)') );\r\n\r\n      this.group.add( innerHZLine );\r\n      this.group.add( outerHZLine );\r\n\r\n      mesh.visible = this.app.options.renderHabitableZone;\r\n\r\n      this.group.add( mesh );\r\n      this.habitableZone = mesh;\r\n      // this.app.habitableZones.push( mesh );\r\n\r\n    }\r\n  }\r\n\r\n};\r\n","import Component from '../app/component';\r\n\r\nexport var __useDefault = true;\r\n\r\nexport default class Search extends Component {\r\n\r\n\tinit() {\r\n\r\n\t\tthis.searchInput = $(this.node).find('input#search'),\r\n\t\tthis.timeout = null;\r\n\r\n\t\tthis.initControls();\r\n\r\n\t}\r\n\r\n\tinitControls() {\r\n\r\n\t\tvar self = this;\r\n\r\n\t\tthis.searchInput.on('keyup', function(e){\r\n\t\t\te.preventDefault();\r\n\r\n\t\t\tvar val = $(this).val();\r\n\r\n\t\t\tclearTimeout(self.timeout);\r\n\r\n\t\t\tself.timeout = setTimeout(function(){\r\n\t\t\t\tif (val.length >= 3) {\r\n\r\n\t\t\t\t\tself.call(val);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t$(this.node).find('ul').remove();\r\n\r\n\t\t\t\t}\r\n\t\t\t}, 200);\r\n\r\n\t\t});\r\n\t}\r\n\r\n\tcall( val ){\r\n\t\tvar self = this;\r\n\r\n\t\t$.ajax({\r\n\t\t\turl: $(this.node).data('url'),\r\n\t\t\tdata: 'key=' + val,\r\n\t\t\tsuccess: function(data){\r\n\r\n\t\t\t\tself.renderResultList(data);\r\n\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\trenderResultList(data) {\r\n\t\tif (data) {\r\n\r\n\t\t\t$(this.node).find('ul').remove();\r\n\t\t\t$(this.node).append(data);\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n\r\n}","import $ from 'jquery';\r\nimport THREE from 'three.js';\r\n\r\nexport var __useDefault = true;\r\n\r\nexport default class Shader {\r\n\r\n\r\n\tconstructor ( options = {} ) {\r\n\r\n\t\tthis.options = options;\r\n\r\n\t\tthis.shader = this.options.shader;\r\n\t\tthis.uniforms = this.options.uniforms || [];\r\n\t\tthis.attributes = this.options.attributes || [];\r\n\r\n\t\tthis.isAnimateable = true;\r\n\t\tthis.material = null;\r\n\r\n\t\tthis.materials = {\r\n\t\t\tvertex: '',\r\n\t\t\tfragment: ''\r\n\t\t}\r\n\r\n\t\tthis.i = 2;\r\n\r\n\t}\r\n\r\n\r\n\tload ( callback = {} ) {\r\n\r\n\t\tthis.call({\r\n\t\t\turl: '../src/js/shaders/vertex-shader-'+ this.shader +'.js',\r\n\t\t\tshaderType: 'vertex',\r\n\t\t\tcallback: callback\r\n\t\t});\r\n\r\n\t\tthis.call({\r\n\t\t\turl: '../src/js/shaders/fragment-shader-'+ this.shader +'.js',\r\n\t\t\tshaderType: 'fragment',\r\n\t\t\tcallback: callback\r\n\t\t});\r\n\r\n\t}\r\n\r\n\r\n\tgetMaterial () {\r\n\t\treturn this.material;\r\n\t}\r\n\r\n\r\n\tsetMaterial () {\r\n\r\n\t\tthis.material = new THREE.ShaderMaterial({  \r\n\t\t  uniforms: this.uniforms,\r\n\t\t  vertexShader: this.materials['vertex'],\r\n\t\t  fragmentShader: this.materials['fragment'],\r\n\r\n\t\t\tblending: THREE.NormalBlending,\r\n\r\n\t\t  transparent: true,\r\n\t\t  depthTest: false,\r\n\t\t  depthWrite: false\r\n\t\t});\r\n\r\n\r\n\t\t// this.uniforms.tNoise.value.wrapS = this.uniforms.tNoise.value.wrapT = THREE.RepeatWrapping;\r\n\r\n\t}\r\n\r\n\r\n\tsetAttributes ( attributes = {} ) {\r\n\t\tthis.attributes = attributes;\r\n\t}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\tcall ( options = {} ) {\r\n\r\n\t\t$.ajax({\r\n\t\t\turl: options.url,\r\n\t\t\tdataType: 'text',\r\n\t\t\tasync: false,\r\n\t\t\tsuccess: (data) => {\r\n\r\n\t\t\t\tthis.materials[options.shaderType] = data;\r\n\t\t\t\tthis.i--;\r\n\r\n\t\t\t\tif (this.i == 0) {\r\n\t\t\t\t\tthis.setMaterial();\r\n\t\t\t\t\toptions.callback(data);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t}\r\n\r\n}","import THREE from 'three.js';\r\n\r\nimport Utils from '../app/utils';\r\n\r\nexport default class SpaceObject {\r\n\r\n\r\n\tconstructor (options = {}) {\r\n\r\n\t\tthis.options = options;\r\n\r\n\t\tthis.app = this.options.app;\r\n\t\tthis.data = options.data;\r\n\t\tthis.utils = new Utils();\r\n\r\n\t\tthis.object = new THREE.Mesh();\r\n\t\tthis.textureLoader = new THREE.TextureLoader();\r\n\r\n\t\tthis.objectPlane = new THREE.Group();\r\n\t\t// this.options.group.add( this.objectPlane );\r\n\r\n\t\tthis.hasTexture = false;\r\n\t\tthis.hasShader = false;\r\n\r\n\t\tthis.init();\r\n\r\n\t}\r\n\r\n\tinit() {\r\n\r\n\t\tthis.render();\r\n\r\n\t\tif (this.hasTexture)\r\n\t\t\tthis.loadTexture();\r\n\r\n\t\tif (this.hasShader)\r\n\t\t\tthis.loadShader();\t\t\t\r\n\r\n\t}\r\n\r\n\t// @override\r\n\trender() {\r\n\r\n\t}\r\n \r\n\r\n  loadTexture() {}\r\n\r\n  loadShader() {}\r\n\r\n\r\n  getObject() {\r\n\r\n  \treturn this.objectPlane;\r\n\r\n  }\r\n\r\n\t// @override\r\n  animate() {}\r\n\r\n}","import Component from '../app/component';\r\n\r\nexport var __useDefault = true;\r\n\r\nexport default class Tabs extends Component {\r\n\r\n\tinit() {\r\n\r\n\t\tthis.tabMenuItems = $(this.node).find('.tab-menu .tab-item');\r\n\t\tthis.tabContentTabs = $(this.node).find('.tab-content .tab');\r\n\r\n\t\tthis.initControls();\r\n\r\n\t}\r\n\r\n\tinitControls() {\r\n\t\t\r\n\t\tvar self = this;\r\n\r\n\t\tthis.tabMenuItems.on('click', function(e){\r\n\t\t\te.preventDefault();\r\n\r\n\t\t\tself.tabMenuItems.removeClass('active');\r\n\t\t\t$(this).addClass('active');\r\n\r\n\t\t\tself.toggleTabContent( $(e.currentTarget).data('id') );\r\n\t\t});\r\n\r\n\t}\r\n\r\n\ttoggleTabContent( id ) {\r\n\t\tvar self = this;\r\n\t\tvar targetTabID = id;\r\n\t\tvar targetTab = $(this.node).find('#' + targetTabID);\r\n\r\n\t\tif (!targetTab.length) {\r\n\t\t\t\r\n\t\t\tconsole.log('tab content pane not found');\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( !targetTab.hasClass('active') ) {\r\n\t\t\t\tself.tabContentTabs.removeClass('active');\r\n\t\t\t\ttargetTab.addClass('active');\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}","\r\nimport $ from 'jquery';\r\nimport _ from 'underscore';\r\nimport THREE from 'three.js';\r\nimport Stats from 'stats';\r\n\r\nimport Utils from '../app/utils';\r\nimport PlanetSystem from './planetsystem';\r\n\r\nimport Solarsystem from '../data/solarsystem';\r\nimport ParticleStars from './particlestars';\r\n\r\nimport DistanceCircles from './distancecircles';\r\nimport CanvasElement from './canvaselement';\r\n\r\nimport Textures from '../helpers/textures';\r\nimport Shader from './shader';\r\n\r\nimport Label from '../views/label';\r\nimport InfoBox from '../views/infobox';\r\n\r\nexport default class ThreeScene {\r\n  \r\n  constructor (options = {}) {\r\n\r\n  \tthis.utils = new Utils();\r\n  \tthis.options = options;\r\n\r\n  \tthis.systems = [];\r\n  \tthis.orbits = [];\r\n  \tthis.meshes = [];\r\n\r\n  \tthis.labels = [];\r\n\r\n  \tthis.stars = [];\r\n  \tthis.particles = 'p';\r\n\r\n  \tthis.raycaster = new THREE.Raycaster();\r\n  \tthis.mouse = new THREE.Vector2();\r\n  \tthis.fustum = new THREE.Frustum();\r\n\r\n\r\n  \t// to be optimized\r\n  \tthis.time = Date.now();\r\n\t\tthis.simTime = this.time;\r\n\t\tthis.simTimeSecs = null;\r\n\r\n\t\tthis.defaultSpeed = 100;\r\n\r\n\t\tthis.startTime = _.now();\r\n\r\n\t\t// current speed (1 earth day represents 365/100 seconds in app)\t\r\n\t\tthis.currentSpeed = 100;\r\n\t\tthis.speedStep = 100;\r\n\r\n\t\tthis.date = new Date( this.simTime );\r\n\t\tthis.timeElapsedSinceCameraMove = 0;\r\n\t\tthis.timeElapsed = 0;\r\n\r\n\r\n\r\n\t\tthis.clock = new THREE.Clock();\r\n\t\tthis.delta = 0;\r\n\t\tthis.timeElapsed = 0;\r\n\r\n\r\n\r\n  \tthis.distanceCircles = null;\r\n\r\n  \tthis.center = new THREE.Vector3(0,0,0);\r\n\r\n  \tthis.currentSpeed = 100;\r\n\r\n  \tconsole.log('loading scene');\r\n\r\n  \tthis.prepareScene();\r\n    this.init();\r\n\r\n  }\r\n\r\n  prepareScene() {\r\n\r\n  \tthis.scene = new THREE.Scene();\r\n\t\tthis.renderer;\r\n\t\tthis.camera; \r\n\t\tthis.cameraControls;\r\n\t\tthis.controls;\r\n\r\n  \tif (this.utils.isWebGLSupported()) {\r\n\r\n\t\t\tthis.renderer = new THREE.WebGLRenderer({\r\n\t\t\t\tantialias: true\r\n\t\t\t});\r\n\r\n\t\t\tthis.renderer.setClearColor( 0x000000, 1 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tlet message = new Message({text: 'No WebGL', state: 'info'});\r\n\t\t\t\t\tmessage.render();\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\r\n\t\t// the position which the camera is currently looking at\r\n\t\t//this.cameraTarget = new THREE.Vector3(-4896521386, -5806265224, -1029922198);\r\n\t\tthis.cameraTarget = new THREE.Vector3(0,0,0);\r\n\r\n\t\t// the current center position (planet systems will be rendered to this point)\r\n\t\tthis.center = new THREE.Vector3(0,0,0);\r\n\r\n\t\t// this.cameraHelper = new CameraHelper({ app: self });\r\n\r\n\t\tthis.renderer.setSize( window.innerWidth, window.innerHeight );\r\n\t\tthis.renderer.shadowMap.enabled = true;\r\n\r\n\t\tthis.container = document.getElementById('scene');\r\n\t\tthis.container.appendChild(this.renderer.domElement);\r\n\r\n\t  // add event listeners\r\n\t  //document.addEventListener( 'mousedown', (e) => this.onDocumentMouseMove(e), false );\r\n\t  //document.addEventListener( 'mousemove', (e) => this.onDocumentMouseMove(e), false );\r\n\t  //document.addEventListener( 'mouseover', (e) => this.onDocumentMouseMove(e), false );\r\n\r\n  }\r\n\r\n\r\n  init() {\r\n\r\n  \tthis.initCamera();\r\n\t\tthis.initLighting();\r\n\t\tthis.initResize();\r\n\r\n\t  this.renderStats();\r\n\r\n\r\n\t  //this.distanceCircles = new DistanceCircles({app: this});\r\n\r\n\t  this.renderCoordinateSystem('galaxy');\r\n\t\tthis.renderGalaxyClusters();\r\n\r\n\t\tthis.renderGalaxyGroups();\r\n\r\n\t\t// render global views\r\n\t\tthis.$infoBox = new InfoBox({app: this});\r\n\r\n\t  this.animate();\r\n\r\n  }\r\n\r\n\r\n\r\n  initCamera( target ) {\r\n\r\n  \tvar self = this;\r\n\r\n  \tif (target !== undefined || target != null)\r\n  \t\tself.cameraTarget = target;\r\n\r\n\t\tthis.camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.0001, 10000000000 );\r\n\t\tthis.camera.updateProjectionMatrix();\r\n\r\n\t\tlet pos = {\r\n\t\t\tx: this.utils.getDistance(1000000, 'ly')\r\n\t\t}\r\n\r\n\t\tpos.y = pos.x;\r\n\t\tpos.z = pos.x;\r\n\r\n\t\tconsole.log('rendering camera at:', pos.x, pos.y, pos.z);\r\n\r\n\t\tthis.camera.position.set( pos.x, pos.y, pos.z );\r\n\t\t\r\n\t\tthis.scene.add(this.camera);\r\n\t\tthis.controls = new THREE.TrackballControls( this.camera, this.container );\r\n\r\n\t\t//var vector = new THREE.Vector3( this.controls.target.x, this.controls.target.y, this.controls.target.z );\r\n  \t\t\t//vector.applyQuaternion( this.camera.quaternion );\r\n\r\n  \tthis.cameraTarget = this.controls.target;\r\n\r\n\t\tif (target !== undefined || target != null) {\r\n\t\t\t// window.utils.debug('defining new camera target', target);\r\n\r\n\t\t\t// define the camera position\r\n\t\t\t//this.cameraHelper.setCameraPosition(target);\t\r\n\r\n\t\t\t// define the target which the camera shoul look at\r\n\t\t\t//this.cameraHelper.setCameraTarget(target);\r\n\r\n\t\t} else {\r\n\t\t\tthis.camera.lookAt(this.cameraTarget);\r\n\t\t\t//this.cameraHelper.setCameraTarget( self.cameraTarget );\r\n\t\t}\r\n\r\n\r\n\t\tthis.cameraPosition = new THREE.Vector3();\r\n\t\tthis.cameraPosition = this.cameraPosition.setFromMatrixPosition( this.camera.matrixWorld );\r\n\t\tthis.cameraPositionOld = this.cameraPosition;\r\n\r\n\t  this.controls.rotateSpeed = 2.0;\r\n\t  this.controls.zoomSpeed = 1.8;\r\n\t  this.controls.panSpeed = 1.2;\r\n\r\n\t  //this.controls.minDistance = this.window.utils.makeDistance( 0.0001, 'au');\r\n\r\n\t  //this.controls.noZoom = false;\r\n\t  //this.controls.noPan = false;\r\n\r\n\t  this.controls.staticMoving = true;\r\n\t  this.controls.dynamicDampingFactor = 0.3;\r\n\r\n\t  //this.controls.keys = [ 65, 83, 68 ];\r\n\t  this.controls.addEventListener( 'change', this.render() );\r\n  }\r\n\r\n\r\n\tinitLighting() {\r\n\r\n  \t// create a point light\r\n\t  this.pointLight = new THREE.PointLight(0xFFFFFF, 1);\r\n\t  this.pointLight.position.set(10000, 10000, 10000);\r\n\t  this.scene.add( this.pointLight );\r\n\r\n\t  // add a very light ambient light\r\n\t  var globalLight = new THREE.AmbientLight(0xccffcc);\r\n\r\n\t  globalLight.color.setRGB( \r\n\t  \tthis.options.globalLightIntensity,\r\n\t  \tthis.options.globalLightIntensity,\r\n\t  \tthis.options.globalLightIntensity\r\n\t  );\r\n\r\n\t  this.scene.add( globalLight );\r\n\r\n\r\n\r\n\t  var light = new THREE.DirectionalLight( 0xffffbb, 1 );\r\n\t\t\t\tlight.position.set( -1000, 1000, - 1000 );\r\n\r\n\t\tthis.scene.add( light );\r\n  }\r\n\r\n\r\n  renderGalaxyClusters () {\r\n\t\tvar self = this;\r\n\r\n\t\t$.ajax({\r\n\t\t  url: '../public/data/local_group.json?time=' + Math.random(),\r\n\t\t  dataType: 'json',\r\n\t\t  success: (galaxies) => {\r\n\r\n\t\t  \tlet r = this.utils.redshiftToParsec(11.1);\r\n\t\t  \tconsole.log('parsec', r);\r\n\r\n\t\t  \tconsole.log(galaxies);\r\n\t\t  \t\r\n\t\t  \tvar textures = new Textures();\r\n\r\n\t\t\t\tlet num_particles = galaxies.length;\r\n\r\n\t\t\t\tlet attributes = {\r\n\t\t      sizes: [],\r\n\t\t      colors: [],\r\n\t\t      alpha: []\r\n\t\t    };\r\n\r\n\t\t    let uniforms = {\r\n\t\t      amplitude: { type: 'f', value: 1.0 },\r\n\t\t      texture: { type: 't', value: textures.getStarMaterial() }\r\n\t\t    };\r\n\r\n\r\n\t\t    let geometry = new THREE.BufferGeometry();\r\n\r\n\t\t    var positions = new Float32Array( num_particles * 3 );\r\n\t\t    var starColors = new Float32Array( num_particles * 3 );\r\n\t\t    var starSizes = new Float32Array( num_particles );\r\n\r\n\t\t    var color = new THREE.Color(0xe0e0ff);\r\n\r\n\t\t    for ( var i = 0, i3 = 0; i < num_particles; i++, i3 += 3 ) {\r\n\r\n\t\t    \tvar g = galaxies[i];\r\n\r\n\t\t    \t// var dist = this.utils.redshiftToParsec(g.z);\r\n\t\t    \tvar dist = this.utils.getDistance(g.d, 'ly'); \r\n\r\n\t\t    \tg.ra *= Math.PI / 180.0;\r\n\t\t    \tg.dec *= Math.PI / 180.0;\r\n\r\n\t\t    \tvar x = dist * Math.cos( g.dec ) * Math.cos( g.ra );\r\n      \t\tvar y = dist * Math.cos( g.dec ) * Math.sin( g.ra );\r\n      \t\tvar z = dist * Math.sin( g.dec );\r\n\r\n      \t\t//x = this.utils.PCToLY(x);\r\n      \t\t//y = this.utils.PCToLY(y);\r\n      \t\t//z = this.utils.PCToLY(z);\r\n\r\n      \t\t// console.log(x,y,z);\r\n\r\n\t\t      positions[ i3 + 0 ] = x;\r\n\t\t      positions[ i3 + 1 ] = y;\r\n\t\t      positions[ i3 + 2 ] = z;\r\n\r\n\t\t      starSizes[ i ] = 1000000;\r\n\r\n\t\t      if (g.w && g.h) {\r\n\r\n\t\t      \tstarSizes[ i ] = g.w * 100;\r\n\r\n\t\t      }\r\n\r\n\t\t      //color.setHSL( i / num_particles, 1.0, 0.5 );\r\n\r\n\t\t      starColors[ i3 + 0 ] = color.r;\r\n\t\t      starColors[ i3 + 1 ] = color.g;\r\n\t\t      starColors[ i3 + 2 ] = color.b;\r\n\r\n\r\n\t\t      this.labels.push(new Label({ \r\n\t\t\t\t\t\tapp: this, \r\n\t\t\t\t\t\tid: g.i,\r\n\t\t\t\t\t\tname: g.n,\r\n\t\t\t\t\t\tposition: {x:x, y:y, z:z}\r\n\t\t\t\t\t}));\r\n\r\n\t\t    }\r\n\r\n\r\n\t\t    geometry.addAttribute('position', new THREE.BufferAttribute( positions, 3 ) );\r\n\t\t    geometry.addAttribute('color', new THREE.BufferAttribute( starColors, 3 ) );\r\n\t\t    geometry.addAttribute('size', new THREE.BufferAttribute( starSizes, 1 ) );\r\n\r\n\r\n\t\t    var particleMaterial = new THREE.ShaderMaterial({\r\n\r\n\t\t      uniforms: uniforms,\r\n\t\t      blending: THREE.NormalBlending,\r\n\t\t      depthTest: false,\r\n\t\t      depthWrite: false,\r\n\t\t      transparent: true\r\n\r\n\t\t    });\r\n\r\n\r\n\t\t    var shader = new Shader({\r\n\r\n\t\t      shader: 'particle-star',\r\n\r\n\t\t      uniforms: uniforms,\r\n\t\t      attributes: attributes\r\n\r\n\t\t    });\r\n\r\n\r\n\t\t    shader.load( () => {\r\n\r\n\t\t      particleMaterial = shader.getMaterial();\r\n\r\n\t\t    });\r\n\r\n\t\t    var particleSystem = new THREE.Points(\r\n\t\t      geometry,\r\n\t\t      particleMaterial\r\n\t\t    );\r\n\r\n\t\t    particleSystem.dynamic = true;\r\n\r\n\t\t    // rotate the whole particle system by 39 degrees\r\n\t\t    // see http://www.astronews.com/forum/archive/index.php/t-3533.html\r\n\t\t    // particleSystem.rotation.x = -39 * (Math.PI/180);\r\n\t\t      \r\n\t\t    this.scene.add( particleSystem );\r\n\r\n\t\t    this.updateLabels();\r\n\t\t  }\r\n\r\n\t\t});\r\n\r\n\t}\r\n\r\n\r\n\trenderCoordinateSystem (type){\r\n    var self = this;\r\n\r\n    var coordinateSystems = {\r\n    \t'galaxy': {\r\n        'group': new THREE.Group(),\r\n        'visible': true,\r\n        'settings': {\r\n          'rings': 10,  \r\n          'segments': 64,\r\n          'degrees': 360/16,\r\n          'distance': 11,\r\n          'position': 1,\r\n          'rotation': (Math.PI/2)\r\n      \t}\r\n    \t}\r\n    };\r\n\r\n    coordinateSystems[type].visible = true;\r\n\r\n    console.log('Rendering coordinate system for', type);\r\n\r\n    var settings = coordinateSystems[type].settings;\r\n    var dist = settings.distance * this.utils.distancePixelRatio;\r\n\r\n    var material = new THREE.LineBasicMaterial({ \r\n      blending: THREE.AdditiveBlending,\r\n      color: new THREE.Color(0x101010),\r\n      depthTest: false,\r\n      depthWrite: false,\r\n      transparent: false\r\n    });\r\n\r\n    var dashMaterial = new THREE.LineDashedMaterial({ \r\n      blending: THREE.AdditiveBlending,\r\n      color: new THREE.Color(0x303030),\r\n      opacity: 0.5,\r\n      depthTest: false,\r\n      depthWrite: false,\r\n      transparent: true,\r\n      dashSize: dist/36, \r\n      gapSize: dist/36\r\n    });\r\n\r\n    //var axes = new THREE.AxisHelper(100);\r\n\t\t//this.scene.add(axes);\r\n\r\n\t\t// 1 mio ly\r\n\t\tvar scaleFactor = this.utils.getDistance(100000, 'ly'); \r\n\r\n\r\n    // render the rings\r\n    for (var i = 0; i < settings.rings + 1; i++) {\r\n\r\n    \tvar arcShape = new THREE.Shape();\r\n\t\t\t\t\tarcShape.moveTo( 10, 0 );\r\n\t\t\t\t\tarcShape.absarc( 0, 0, 10, 0, Math.PI*2, false );\r\n\t\t\t\t\tarcShape.autoClose = true;\r\n\r\n\t\t\tvar points = arcShape.createPointsGeometry(64);\r\n\r\n\t\t\tvar line = new THREE.Line( points, new THREE.LineBasicMaterial( { color: new THREE.Color(0x101010), linewidth: 3 } ) );\r\n\t\t\t\t\tline.position.set( 0, 0, 0 );\r\n\t\t\t\t\tline.rotation.set( Math.PI/2, 0, 0 );\r\n\t\t\t\t\tline.scale.set( i*scaleFactor + scaleFactor, i*scaleFactor + scaleFactor, i*scaleFactor + scaleFactor );\r\n\t\t\t\t\tthis.scene.add( line );\r\n\r\n\r\n\t\t\t/*\r\n      var circle = new THREE.Shape();\r\n          circle.moveTo(dist * i, 0 );\r\n          circle.absarc( 0, 0, i * dist, 0, Math.PI*2, false );\r\n      \r\n      var points = circle.createPointsGeometry(settings.rings);\r\n\r\n      var circleLine = new THREE.Line(points, \r\n        new THREE.LineBasicMaterial({ \r\n          color: new THREE.Color(0xff0000),\r\n          opacity: 0.5,\r\n          blending: THREE.AdditiveBlending,\r\n          linewidth: 1,\r\n          depthTest: false,\r\n          depthWrite: false,\r\n          transparent: true\r\n        })\r\n      );\r\n      \r\n      // add one AU as offset to move it to the center    \r\n      // v_circle.position.set(0, -100, 0);    \r\n      if (settings.position !== undefined)\r\n        circleLine.position.set(settings.position, 0, 0);\r\n      else\r\n        circleLine.position.set(0, 0, 0);\r\n\r\n      if (settings.rotation !== undefined) \r\n        circleLine.rotation.set(settings.rotation, 0, 0);\r\n      else\r\n        circleLine.rotation.set(Math.PI/2, 0, 0);\r\n\r\n      coordinateSystems[type].group.add( circleLine );\r\n\r\n      */\r\n    }\r\n\r\n     // render the angles\r\n    for (var i = 0; i < settings.segments; i++) {\r\n\r\n      var geometry = new THREE.Geometry();\r\n          geometry.vertices.push( new THREE.Vector3(0, 0, 0) );\r\n          geometry.vertices.push( new THREE.Vector3(settings.rings * settings.distance * scaleFactor, 0, 0) );\r\n          geometry.computeLineDistances();\r\n\r\n      var shapeLine = null;\r\n      if ( (i * 10) % 30 == 0 )\r\n        shapeLine = new THREE.Line(geometry, material);\r\n      else\r\n        shapeLine = new THREE.Line(geometry, material);\r\n\r\n      if (settings.position !== undefined)\r\n        shapeLine.position.set(0, 0, 0);\r\n      else\r\n        shapeLine.position.set(0, 0, 0);\r\n\r\n      if (settings.rotation !== undefined) \r\n        shapeLine.rotation.set(settings.rotation, 0, 10 * i * this.utils.toRad());\r\n      else\r\n        shapeLine.rotation.set(Math.PI/2, 0, 10 * i * this.utils.toRad());\r\n\r\n      coordinateSystems[type].group.add( shapeLine );\r\n    }\r\n\r\n    coordinateSystems[type].group.position.set(0,0,0);\r\n    this.scene.add( coordinateSystems[type].group );\r\n  }\r\n\r\n\r\n  renderGalaxyGroups () {\r\n\r\n  \tlet positions = [\r\n  \t\t{x: this.utils.getDistance(27000,'ly'), y:0, z:0},\r\n  \t]\r\n\r\n  \tpositions.forEach( (position) => {\r\n\r\n  \t\tvar v = new THREE.Vector3(position);\r\n  \t\tvar sphereGeom =  new THREE.SphereGeometry( this.utils.getDistance(400000,'ly'), 64, 32 );\r\n\t\t\tvar blueMaterial = new THREE.MeshBasicMaterial({ \r\n\t\t\t\tcolor: 0x5050ff, \r\n\t\t\t\ttransparent: true, \r\n\t\t\t\topacity: 0.15 \r\n\t\t\t});\r\n\r\n\t\t\tvar sphere = new THREE.Mesh( sphereGeom, blueMaterial );\r\n\r\n\t\t\tsphere.position.set(-100, 50, 50);\r\n\t\t\tthis.scene.add( sphere );\t\r\n\r\n  \t});\r\n\r\n  }\r\n\r\n\r\n  renderStats ( container = $('body') ) {\r\n  \tthis.stats = new Stats();\r\n\r\n  \t$(this.stats.domElement).attr('class', 'stats');\r\n  \t$(this.stats.domElement).css({\r\n\t\t\t'position': 'absolute',\r\n\t\t\t'bottom': '0',\r\n\t\t\t'z-index': 99\r\n\t\t});\r\n\r\n\t\tcontainer.append( this.stats.domElement );\r\n  }\r\n\r\n\r\n  updateLabels () {\r\n\r\n  \tthis.labels.forEach((label) => {\r\n\t\t\tlabel.updatePosition();\r\n\t\t});\r\n\r\n  }\r\n\r\n\r\n  initResize() {\r\n\r\n\t\twindow.addEventListener('resize', () => {\r\n\r\n      let w = window.innerWidth;\r\n      let h = window.innerHeight;\r\n\r\n      this.renderer.setSize( w, h );\r\n      this.camera.aspect = w / h;\r\n      this.camera.updateProjectionMatrix();\r\n\r\n      this.updateLabels();\r\n    });\r\n\r\n  }\r\n\r\n\r\n\tanimate ( step ){\r\n  \tthis.timeElapsed = step;\r\n\r\n    // loop on request animation loop\r\n\t\t// - it has to be at the begining of the function\r\n\t\t// - see details at http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\r\n\t\trequestAnimationFrame( this.animate.bind( this ) );\r\n\t\tthis.controls.update();\r\n\r\n\r\n\t  // set the time\r\n\t  this.lastTime = this.time;\r\n\t  this.time = Date.now();\r\n\t  this.dt = this.time - this.lastTime;\r\n\t  this.simTime += this.dt * this.currentSpeed;\r\n\t  this.date = new Date(this.simTime);\r\n\t  this.simTimeSecs = this.simTime;\r\n\r\n\t\tthis.render(step);\r\n\r\n\t\tthis.stats.update();\r\n  }\r\n\r\n\r\n  render (step) {\r\n\t\tvar self = this;\r\n\r\n\r\n\t\tthis.delta = this.clock.getDelta();\r\n\t\tthis.timeElapsed = this.clock.getElapsedTime();\r\n\r\n\t\t// this.renderCount++;\r\n\t\tvar now = _.now();\r\n\t\tvar currentDate = new Date(now - this.startTime);\r\n\t\tvar secondsElapsed = currentDate.getSeconds();\r\n\t\tvar minutesElapsed = currentDate.getMinutes();\r\n\t\t// window.utils.debug('time since app start', minutesElapsed + 'm ' + secondsElapsed + 's');\r\n\r\n\t\tthis.currentRenderLoops++;\r\n\r\n\t\t// calculate current distance from solar center\r\n\t\tthis.cameraPosition = new THREE.Vector3();\r\n\t\tthis.cameraPosition = this.cameraPosition.setFromMatrixPosition( this.camera.matrixWorld );\r\n\r\n\t\t// distance in px\r\n\t\tthis.distanceCamera = this.cameraPosition.distanceTo( self.cameraTarget );\r\n\t\tvar distanceSolarCenter = this.distanceCamera * this.utils.distancePixelRatio;\r\n\r\n\t\tvar distanceAU = parseFloat(distanceSolarCenter / this.utils.AU).toFixed(2);\r\n\t\tvar distanceLY = parseFloat(distanceSolarCenter / this.utils.LY).toFixed(2);\r\n\t\tvar distancePC = parseFloat(distanceLY / this.utils.PC).toFixed(2);\r\n\r\n\t\tthis.currentDistanceLY = distanceLY;\r\n\r\n\t\tdistanceSolarCenter = this.utils.numberFormat( this.distanceCamera * this.utils.distancePixelRatio );\r\n\r\n\r\n\t\t// calculate current distance from solar center\r\n\t\tthis.cameraPosition = new THREE.Vector3();\r\n\t\tthis.cameraPosition = this.cameraPosition.setFromMatrixPosition( this.camera.matrixWorld );\r\n\r\n\t\t// distance in px\r\n\t\tthis.distanceCamera = this.cameraPosition.distanceTo( self.cameraTarget );\r\n\t\tvar distanceSolarCenter = this.distanceCamera * this.utils.distancePixelRatio;\r\n\r\n\t\tvar distanceAU = parseFloat(distanceSolarCenter / this.utils.AU).toFixed(0);\r\n\t\tvar distanceLY = parseFloat(distanceSolarCenter / this.utils.LY).toFixed(0);\r\n\t\tvar distancePC = parseFloat(distanceLY / this.utils.PC).toFixed(0);\r\n\r\n\t\tthis.currentDistanceLY = distanceLY;\r\n\r\n\t\tdistanceSolarCenter = this.utils.numberFormat( this.distanceCamera * this.utils.distancePixelRatio );\r\n\r\n\t\t//$('#distance-km').text( distanceSolarCenter );\r\n\t\t//$('#distance-au').text( distanceAU );\r\n\t\t$('#distance-ly').text( distanceLY );\r\n\t\t$('#distance-pc').text( distancePC );\r\n\r\n\r\n\t\t// check if camera position changed and recalculate star sizes\r\n\t\tif (this.cameraPosition.y != this.cameraPositionOld.y) {\r\n\t\t\tthis.cameraPositionOld = this.cameraPosition;\r\n\t\t\tconsole.log('camera changed');\r\n\r\n\t\t\tthis.updateLabels();\r\n\t\t}\r\n\r\n\t\tthis.renderer.render( this.scene, this.camera );\r\n\t}\r\n\r\n\r\n\r\n  onDocumentMouseMove(e) {\r\n\r\n\t\te.preventDefault();\r\n\r\n\t\tthis.updateMousePosition(e);\r\n\r\n\t\t//var self = this;\r\n\t\t//var vector = new THREE.Vector3( ( e.clientX / window.innerWidth ) * 2 - 1, - ( e.clientY / window.innerHeight ) * 2 + 1, .5 );\r\n\t\t// this.projector.unprojectVector( vector, this.camera );\r\n\r\n\t\t//vector.unproject(this.camera);\r\n\r\n\t\t//var rayCaster = new THREE.Raycaster( this.camera.position, vector.sub( this.camera.position ).normalize() );\r\n\t\r\n\r\n\t\t/*\r\n\t\t_.each( self.markers, function( marker, idx ){\r\n\t\t\tself.scene.remove( marker );\r\n\t\t});\r\n\t\t*/\r\n\r\n\t\t\r\n\t\t// var intersects = rayCaster.intersectObjects( this.meshes, true );\r\n\r\n\r\n\t\t//  check intersection of stars\r\n\t\tthis.intersectStars(e);\r\n\r\n\t\t// var mouse = { x: 0, y: 0, z: 1 };\r\n\r\n\t\t\r\n\r\n\t\t// this where begin to transform the mouse cordinates to three.js cordinates\r\n\t  // mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;\r\n\t  // mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;\r\n\t    \r\n\t  // this vector caries the mouse click cordinates\r\n\t  //var mouse_vector = new THREE.Vector3(0,0,0);\r\n\t  \t\t//mouse_vector.set( mouse.x, mouse.y, mouse.z );\r\n\r\n\t \t// this.projector.unprojectVector( mouse_vector, this.camera );\r\n\t  \r\n\t  //mouse_vector.unproject(this.camera);\r\n\r\n\t  //var direction = mouse_vector.sub( this.camera.position ).normalize();\r\n\t  //rayCaster.set( this.camera.position, direction );\r\n\t    \r\n\r\n\r\n\t\t// check if the user moves the mouse over a planet or host star\r\n\t\t/*\r\n\t\t_.each( this.meshes, function( mesh, idx ){\r\n\t\t\t//window.utils.debug(mesh);\r\n\t\t\tif( mesh.position ) {\r\n\t\t\t\tintersects = rayCaster.intersectObject( [mesh] );\r\n\r\n\t\t\t\tif( intersects.length > 0 ) {\r\n\t  \t\t\twindow.utils.debug( intersects[ 0 ].object );\r\n\t  \t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\t*/\r\n\r\n\t\t// s$('#tooltip').hide();\r\n\t\t// self.canvasElement.hideViewHelper();\r\n\t\t// this.checkStarMouseCollision(e);\r\n\r\n\t}\r\n\r\n\r\n\tupdateMousePosition ( e ) {\r\n\r\n\t\tthis.mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;\r\n\t\tthis.mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;\r\n\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * track mouse movement over stars\r\n\t */\r\n\tintersectStars (e) {\r\n\r\n\t\tif (this.particles) {\r\n\r\n\t\t\tthis.raycaster.setFromCamera( this.mouse, this.camera );\r\n\r\n\t\t\tlet intersects = this.raycaster.intersectObject( this.particles );\r\n\t\t\tlet INTERSECTED;\r\n\r\n\t\t\tif ( intersects.length > 0 ) {\r\n\r\n\t\t\t\tif ( INTERSECTED != intersects[ 0 ].index ) {\r\n\r\n\t\t\t\t\tINTERSECTED = intersects[ 0 ].index;\r\n\r\n\t\t\t\t\t// console.log(intersects[ 0 ]);\r\n\t\t\t\t\tconsole.log( this.loadedStars[INTERSECTED] );\r\n\r\n\t\t\t\t\tthis.canvasElement.updatePosition({\r\n\t\t\t\t\t\tx: e.clientX,\r\n\t\t\t\t\t\ty: e.clientY\r\n\t\t\t\t\t});\r\n\t\t\t\t\t\r\n\t\t\t\t\tthis.canvasElement.registerObject(this.loadedStars[INTERSECTED]);\r\n\t\t\t\t\tthis.canvasElement.showTooltip();\r\n\t\t\t\t\tthis.canvasElement.show();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( INTERSECTED !== null ) {\r\n\r\n\t\t\t\tINTERSECTED = null;\r\n\t\t\t\tthis.canvasElement.hide();\r\n\t\t\t\tthis.canvasElement.hideTooltip();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\r\n\tcheckStarMouseCollision (e) {\r\n\r\n\r\n\t\tif (!this.isMouseOverElement(e)) {\r\n\r\n\t\t\t// check if user moves the mouse near a star\r\n\t\t\tthis.stars.forEach(( star, idx ) => {\r\n\r\n\t\t\t\tif (star) {\r\n\r\n\t\t\t\t\tvar pos = this.utils.getPosition2D( star, this );\r\n\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (star.properties.id <= 100) {\r\n\t\t\t\t\t\t// console.log(pos.x);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( pos.x >= (e.clientX - 5) && pos.x <= (e.clientX + 5) ) {\r\n\t\t\t\t\t\tif ( pos.y >= (e.clientY - 5) && pos.y <= (e.clientY + 5) ) {\r\n\r\n\t\t\t\t\t\t\tconsole.log('star hovered');\r\n\r\n\t\t\t\t\t\t\tthis.canvasElement.updatePosition(pos);\r\n\t\t\t\t\t\t\tthis.canvasElement.updateObjectInfo(star);\r\n\t\t\t\t\t\t\tthis.canvasElement.showTooltip();\r\n\t\t\t\t\t\t\tthis.canvasElement.showViewHelper();\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t});\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// check over which element the mouse is\r\n\tisMouseOverElement (event){\r\n\t\tlet el = document.elementFromPoint(event.clientX, event.clientY);\r\n    return !$(el).is('canvas') && !$(el).hasClass('habitable-star-label');\r\n\t} \r\n\r\n\r\n}\r\n\r\n"],"sourceRoot":"/source/"}